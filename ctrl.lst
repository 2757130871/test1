C51 COMPILER V9.52.0.0   CTRL                                                              10/13/2016 08:51:49 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CTRL
OBJECT MODULE PLACED IN .\ctrl.obj
COMPILER INVOKED BY: G:\Keil for C51\C51\BIN\C51.EXE ..\code\ctrl.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\ctrl.lst) TA
                    -BS(2) OBJECT(.\ctrl.obj)

line level    source

   1          #include "reg52.h"
   2          #include "string.h"
   3          #include "main.h"
   4          #include "uart.h"  
   5          #include "rc522.h"
   6          #include "ctrl.h"
   7          #include "beep.h"
   8          #include "lcd12864.h"
   9          #include "timer.h"
  10          #include "EEPROM.h"
  11          #include "key.h"
  12          
  13          INT8U states=0;//状态机
  14          
  15          INT8U Card_type[2], //卡片类型
  16                Card_SN[4]={0},//IC卡号
  17              Card_SN_BUF[4]={0xff,0xff,0xff,0xff},//卡号登记缓冲区    
  18              KEY_BUF[8]={'0','0','0','0','0','0','0','0'};
  19          
  20          INT8U bPass = 0; bWarn = 0;    
  21          
  22          void uart_over( void )  //串口数据还原
  23          {
  24   1        UartCount = 0;
  25   1        UartStart = FALSE;
  26   1        UartComp = FALSE;
  27   1      }
  28          
  29          void pass( void )
  30          {
  31   1         beep1();
  32   1         Delay_ms(2000);//让卡片离开
  33   1         LED_BLINK_1();
  34   1      }
  35          
  36          void warn(void)
  37          {
  38   1        LED_BLINK_2();
  39   1      }
  40          
  41          
  42          INT8U IC_READ( void )
  43          {
  44   1          INT8U ID_ASC[8],i;
  45   1        if( PcdRequest( PICC_REQIDL, Card_type ) != MI_OK )//寻天线区内未进入休眠状态的卡，返回卡片类型 2字节 
  46   1        {
  47   2          if( PcdRequest( PICC_REQIDL, Card_type ) != MI_OK )//寻天线区内未进入休眠状态的卡，返回卡片类型 2字节 
  48   2          {
  49   3             
  50   3            return FALSE;
  51   3          } 
  52   2        }
  53   1        
  54   1        if( PcdAnticoll( Card_SN ) != MI_OK ) //防冲撞，返回卡的序列号 4字节 
C51 COMPILER V9.52.0.0   CTRL                                                              10/13/2016 08:51:49 PAGE 2   

  55   1        {
  56   2      
  57   2          bWarn = 1;
  58   2          return FALSE; 
  59   2        }
  60   1      
  61   1        bPass = 1;
  62   1        send_bytes(Card_type,2);
  63   1        send_bytes(Card_SN,4);
  64   1        
  65   1        for(i=0;i<4;i++) //卡ID号转化成ASCII
  66   1        {
  67   2          if(Card_SN[i]/16>9) ID_ASC[i*2]=Card_SN[i]/16+'7';
  68   2            else ID_ASC[i*2]=Card_SN[i]/16+'0';
  69   2      
  70   2            if(Card_SN[i]%16>9) ID_ASC[i*2+1]=Card_SN[i]%16+'7';
  71   2            else ID_ASC[i*2+1]=Card_SN[i]%16+'0';
  72   2        }
  73   1        display2(3,0,"ID: ",4); //显示卡号
  74   1        display2(3,2,ID_ASC,8);
  75   1      
  76   1        return TRUE;
  77   1      }
  78          
  79          
  80          void ctrl_process( void )
  81          {     
  82   1         INT8U i,key_count,key_value=16,table[8]="--------",statesbuf;  
  83   1        
  84   1        if(states!=statesbuf)  //状态改变，清屏
  85   1        {
  86   2            display_clear_line(2);
  87   2            display_clear_line(3);
  88   2          statesbuf=states;
  89   2        }
  90   1          switch(states)
  91   1        {
  92   2             case 0:            //IC卡读卡输入
  93   2                display(1,0,1); 
  94   2                if(IC_READ()) 
  95   2              {
  96   3               
  97   3                      if ((Card_SN[0]==Card_SN_BUF[0])
  98   3                  &&(Card_SN[1]==Card_SN_BUF[1])
  99   3                &&(Card_SN[2]==Card_SN_BUF[2])
 100   3                &&(Card_SN[3]==Card_SN_BUF[3]))
 101   3                {
 102   4                relay_ON();//灯开关
 103   4                display(2,0,5);
 104   4              
 105   4                  }
 106   3                else   display(2,0,6);
 107   3                  relay_OFF();
 108   3               }
 109   2            
 110   2              break;
 111   2      
 112   2              case 1:   
 113   2                 display(1,0,2);    //密码输入
 114   2               display2(3,0,table,8);
 115   2               key_count=0;
 116   2                     while(1)
C51 COMPILER V9.52.0.0   CTRL                                                              10/13/2016 08:51:49 PAGE 3   

 117   2               {  
 118   3                  key_value=key_scan();   
 119   3                if(key_value==12) 
 120   3                 { 
 121   4                   states--;
 122   4                         return;
 123   4                }
 124   3      
 125   3                if(key_value==13)
 126   3                {
 127   4                 states++;
 128   4                 return;
 129   4                }        
 130   3                if(key_value>=0 && key_value <=9)//有按键输入
 131   3                {                             
 132   4                table[key_count++]=key_value+'0';
 133   4                display2(3,0,table,8);      
 134   4                }
 135   3                
 136   3                if(key_value==11)//退格
 137   3                {                   
 138   4                table[--key_count]='-';
 139   4                display2(3,0,table,8);        
 140   4                }
 141   3      
 142   3                if(key_count==8)
 143   3                {
 144   4                   if( table[0]==KEY_BUF[0] &&
 145   4                     table[1]==KEY_BUF[1] &&
 146   4                   table[2]==KEY_BUF[2] &&
 147   4                   table[3]==KEY_BUF[3] &&
 148   4                   table[4]==KEY_BUF[4] &&
 149   4                   table[5]==KEY_BUF[5] &&
 150   4                   table[6]==KEY_BUF[6] &&
 151   4                   table[7]==KEY_BUF[7] )   //密吗正确 
 152   4              
 153   4                   { 
 154   5                   bPass=1;
 155   5                   relay_ON();//灯开关
 156   5                             display(2,0,5);
 157   5                   relay_OFF();
 158   5                   break;         
 159   5                
 160   5                 }
 161   4                  else   //密码错误
 162   4                  { 
 163   5                    relay_OFF();
 164   5                  beep1()  ;
 165   5                  bWarn=1;
 166   5                    display(2,0,6);
 167   5                   break;
 168   5                 }            
 169   4                }
 170   3      
 171   3               }
 172   2                 break ;
 173   2            
 174   2           case 2:    
 175   2                 display(1,0,3);      //IC卡登记
 176   2                   if(IC_READ())  
 177   2               {
 178   3                 
C51 COMPILER V9.52.0.0   CTRL                                                              10/13/2016 08:51:49 PAGE 4   

 179   3                for(i=0;i<4;i++)
 180   3                Card_SN_BUF[i] = Card_SN[i];
 181   3      
 182   3              EEPROM_WRITE(0,Card_SN,4);//写入EEPROM
 183   3               }
 184   2                 break ;
 185   2      
 186   2           case 3:    
 187   2                 display(1,0,4);      //密码设置
 188   2               display2(3,0,table,8);
 189   2               key_count=0;
 190   2               while(1)
 191   2               {  
 192   3                  key_value=key_scan();   
 193   3                if(key_value==12) 
 194   3                 { 
 195   4                   states--;
 196   4                         return;
 197   4                }
 198   3             
 199   3                  if(key_value>=0 && key_value <=9)//有按键输入
 200   3                {                             
 201   4                table[key_count++]=key_value+'0';
 202   4                display2(3,0,table,8);      
 203   4                }
 204   3                
 205   3                if(key_value==11)//退格
 206   3                {                   
 207   4                table[--key_count]='-';
 208   4                display2(3,0,table,8);        
 209   4                }
 210   3      
 211   3                 if(key_count==8 && key_value == 15) //按下确定键
 212   3                
 213   3                { 
 214   4                
 215   4                  for(i=0;i<8;i++)
 216   4                   KEY_BUF[i]=table[i]; 
 217   4                   EEPROM_WRITE(7,KEY_BUF,8);//写入EEPROM
 218   4               
 219   4                 break;
 220   4                 }
 221   3                      }        
 222   2              
 223   2                 break ;
 224   2      
 225   2          default : break;
 226   2      
 227   2         }        
 228   1      
 229   1        if( bPass )    //处理成功
 230   1        {
 231   2          bPass = 0;
 232   2          pass(); 
 233   2        
 234   2        }
 235   1      
 236   1        if( bWarn )      //处理失败
 237   1        {
 238   2          bWarn = 0;
 239   2          warn();
 240   2        }
C51 COMPILER V9.52.0.0   CTRL                                                              10/13/2016 08:51:49 PAGE 5   

 241   1      
 242   1      }
 243          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1092    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =     22      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
