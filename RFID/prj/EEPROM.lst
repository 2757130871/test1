C51 COMPILER V9.52.0.0   EEPROM                                                            10/13/2016 08:51:50 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\EEPROM.obj
COMPILER INVOKED BY: G:\Keil for C51\C51\BIN\C51.EXE ..\code\EEPROM.C LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\EEPROM.lst
                    -) TABS(2) OBJECT(.\EEPROM.obj)

line level    source

   1          //============================================================================
   2          //prjname :STC89C51RC,STC89C52RC,STC89C54RD+ EEPROM例程
   3          //funtion :程序实现P0口,P1口分别驱动LED灯(低电平亮)把两个8位变量count.dat
   4          //         显示出来,这两个个八位约1s自增一次，且变量的值能够掉电保护
   5          //author :viviFire
   6          //说明   :STC89C51RC,STC89C52RC的EEPROM的第一扇区起始地址为0x2000
   7          //    STC89C54RD+的EEPROM的第一扇区起始地址为0x8000,需修改本程序
   8          //    其他芯片请参考手册
   9          //    运用本程序请注明出自 viviFire, http://hi.baidu.com/2vivifire
  10          //    本程序参考 宏晶公司提供的STC5Axx 系列 EEPROM 例子程序
  11          //============================================================================
  12          
  13          #include "reg52.h"
  14          #include "intrins.h"
  15          #include "uart.h"
  16          
  17          
  18          typedef unsigned char INT8U;
  19          typedef unsigned int   INT16U;
  20          
  21          sfr IAP_DATA    = 0xE2;
  22          sfr IAP_ADDRH   = 0xE3;
  23          sfr IAP_ADDRL   = 0xE4;
  24          sfr IAP_CMD     = 0xE5;
  25          sfr IAP_TRIG    = 0xE6;
  26          sfr IAP_CONTR   = 0xE7;
  27          
  28          //定义Flash 操作等待时间及允许IAP/ISP/EEPROM 操作的常数
  29          //#define ENABLE_ISP 0x80 //系统工作时钟<5MHz 时，对IAP_CONTR 寄存器设置此值
  30          //#define ENABLE_ISP 0x81 //系统工作时钟<10MHz 时，对IAP_CONTR 寄存器设置此值
  31          #define ENABLE_ISP 0x82 //系统工作时钟<20MHz 时，对IAP_CONTR 寄存器设置此值
  32          //#define ENABLE_ISP 0x83 //系统工作时钟<40MHz 时，对IAP_CONTR 寄存器设置此值
  33          
  34          #define DATA_FLASH_START_ADDRESS 0x2000 //STC89C51,STC89C52 系列 EEPROM 测试起始地址
  35          //------------------------------------------------------------------------------------------
  36          
  37          INT8U Byte_Read(INT16U add);              //读一字节，调用前需打开IAP 功能
  38          void Byte_Program(INT16U add, INT8U ch); //字节编程，调用前需打开IAP 功能
  39          void Sector_Erase(INT16U add);            //擦除扇区
  40          void IAP_Disable();                       //关闭IAP 功能
  41          void delayms(INT16U z);
  42          void EEPROM_Init();
  43          //------------------------------------------------------------------------------
  44          /*struct EEP_dat
  45          {   
  46          INT16U add;
  47          INT8U dat;
  48          }count;*/
  49          //------------------------------------------------------------------------------
  50          //a: 扇区 (0~7) 代表1到8个扇区
  51          void EEPROM_WRITE(INT8U a,INT8U *p,INT8U b)
  52          { 
  53   1         INT8U i;
  54   1         Sector_Erase(DATA_FLASH_START_ADDRESS+0x200*a);//删除第a+1个扇区内容，才能写入  
C51 COMPILER V9.52.0.0   EEPROM                                                            10/13/2016 08:51:50 PAGE 2   

  55   1      
  56   1         for(i=0;i<b;i++)
  57   1         Byte_Program(DATA_FLASH_START_ADDRESS+0x200*a+i,p[i]);
  58   1         delayms(500);
  59   1      
  60   1      }//-----------------------------------------------------------------------------
  61          void EEPROM_READ(INT8U a, INT8U *p, INT8U b)
  62          {
  63   1         INT8U i;
  64   1         
  65   1         for(i=0;i<b;i++)
  66   1         p[i]=Byte_Read(DATA_FLASH_START_ADDRESS+0x200*a+i);      
  67   1         delayms(500);
  68   1      }//-----------------------------------------------------------------------------
  69          //读一字节，调用前需打开IAP 功能，入口:DPTR = 字节地址，返回:A = 读出字节
  70          INT8U Byte_Read(INT16U add)
  71          {
  72   1          IAP_DATA = 0x00;
  73   1          IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
  74   1          IAP_CMD = 0x01;                 //IAP/ISP/EEPROM 字节读命令
  75   1      
  76   1          IAP_ADDRH = (INT8U)(add>>8);    //设置目标单元地址的高8 位地址
  77   1          IAP_ADDRL = (INT8U)(add&0xff);    //设置目标单元地址的低8 位地址
  78   1      
  79   1          EA = 0;
  80   1          IAP_TRIG = 0x46;   //先送 46h,再送B9h 到ISP/IAP 触发寄存器,每次都需如此
  81   1          IAP_TRIG = 0xB9;   //送完 B9h 后，ISP/IAP 命令立即被触发起动
  82   1          _nop_();
  83   1          EA = 1;
  84   1          IAP_Disable(); //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
  85   1                          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
  86   1          return (IAP_DATA);
  87   1      }//------------------------------------------------------------------------------
  88          
  89          //字节编程，调用前需打开IAP 功能，入口:DPTR = 字节地址, A= 须编程字节的数据
  90          void Byte_Program(INT16U add,INT8U ch)
  91          {
  92   1          IAP_CONTR = ENABLE_ISP;         //打开 IAP 功能, 设置Flash 操作等待时间
  93   1          IAP_CMD = 0x02;                 //IAP/ISP/EEPROM 字节编程命令
  94   1      
  95   1      
  96   1          IAP_ADDRH = (INT8U)(add>>8);    //设置目标单元地址的高8 位地址
  97   1          IAP_ADDRL = (INT8U)(add&0xff);    //设置目标单元地址的低8 位地址
  98   1      
  99   1          IAP_DATA = ch;                  //要编程的数据先送进IAP_DATA 寄存器
 100   1          EA = 0;
 101   1          IAP_TRIG = 0x46;   //先送 46h,再送B9h 到ISP/IAP 触发寄存器,每次都需如此
 102   1          IAP_TRIG = 0xB9;   //送完 B9h 后，ISP/IAP 命令立即被触发起动
 103   1          _nop_();
 104   1          EA = 1;
 105   1          IAP_Disable(); //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
 106   1                          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
 107   1      }//------------------------------------------------------------------------------
 108          
 109          //擦除扇区, 入口:DPTR = 扇区地址
 110          void Sector_Erase(INT16U add)
 111          {
 112   1          IAP_CONTR = ENABLE_ISP;         //打开IAP 功能, 设置Flash 操作等待时间
 113   1          IAP_CMD = 0x03;                 //IAP/ISP/EEPROM 扇区擦除命令
 114   1      
 115   1          IAP_ADDRH = (INT8U)(add>>8);    //设置目标单元地址的高8 位地址
 116   1          IAP_ADDRL = (INT8U)(add&0xff);    //设置目标单元地址的低8 位地址
C51 COMPILER V9.52.0.0   EEPROM                                                            10/13/2016 08:51:50 PAGE 3   

 117   1      
 118   1          EA = 0;
 119   1          IAP_TRIG = 0x46;   //先送 46h,再送B9h 到ISP/IAP 触发寄存器,每次都需如此
 120   1          IAP_TRIG = 0xB9;   //送完 B9h 后，ISP/IAP 命令立即被触发起动
 121   1          _nop_();
 122   1          EA = 1;
 123   1          IAP_Disable(); //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
 124   1                          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
 125   1      }//------------------------------------------------------------------------------
 126          
 127          void IAP_Disable()
 128          {
 129   1          //关闭IAP 功能, 清相关的特殊功能寄存器,使CPU 处于安全状态,
 130   1          //一次连续的IAP 操作完成之后建议关闭IAP 功能,不需要每次都关
 131   1          IAP_CONTR = 0;      //关闭IAP 功能
 132   1          IAP_CMD   = 0;      //清命令寄存器,使命令寄存器无命令,此句可不用
 133   1          IAP_TRIG = 0;      //清命令触发寄存器,使命令触发寄存器无触发,此句可不用
 134   1          IAP_ADDRH = 0;
 135   1          IAP_ADDRL = 0;
 136   1      }//------------------------------------------------------------------------------
 137          void delayms(INT16U z)
 138          {
 139   1      INT16U x,y;
 140   1      for(x=z;x>0;x--)
 141   1         for(y=125;y>0;y--);
 142   1      }//-------------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    348    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
